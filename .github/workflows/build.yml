name: Build Python ARM64 Binary

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  build-arm64-binary:
    name: Build Ubuntu ARM64 Binary
    runs-on: ubuntu-latest-4-cores
    
    # Increase timeout as Nuitka compilation can be slow, especially with --low-memory
    timeout-minutes: 180
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      # --- Cache pip dependencies to speed up subsequent builds ---
      # This creates a cache key based on the hash of the requirements.txt file.
      - name: Cache pip packages
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Set up QEMU for ARM64 cross-compilation
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # --- Create the Nuitka build script ---
      # OPTIMIZATION: Added the --low-memory flag to Nuitka command.
      # This makes Nuitka more conservative with RAM, preventing crashes if the compilation is very intensive.
      - name: Create Python Build Script for Nuitka
        id: create_script
        run: |
          cat > build_app.py << 'BUILD_SCRIPT'
          import os
          import subprocess
          import sys
          
          def find_tcl_tk_paths():
              """Rigorously finds Tcl and Tk library paths for Nuitka."""
              possible_tcl_paths = [
                  '/usr/share/tcltk/tcl8.6',
                  '/usr/lib/aarch64-linux-gnu/tcl8.6',
                  '/usr/lib/tcl8.6',
              ]
              possible_tk_paths = [
                  '/usr/share/tcltk/tk8.6',
                  '/usr/lib/aarch64-linux-gnu/tk8.6',
                  '/usr/lib/tk8.6',
              ]
              tcl_dir = next((path for path in possible_tcl_paths if os.path.isdir(path)), None)
              tk_dir = next((path for path in possible_tk_paths if os.path.isdir(path)), None)
              if not tcl_dir or not tk_dir:
                  print("Standard paths not found, attempting filesystem fallback search...")
                  for root, dirs, _ in os.walk('/usr'):
                      if not tcl_dir and 'tcl8.6' in dirs: tcl_dir = os.path.join(root, 'tcl8.6')
                      if not tk_dir and 'tk8.6' in dirs: tk_dir = os.path.join(root, 'tk8.6')
              return tcl_dir, tk_dir
          
          def main():
              print("=== Starting Python Application Build using Nuitka ===")
              tcl_dir, tk_dir = find_tcl_tk_paths()
              if not tcl_dir or not tk_dir:
                  print("âŒ FATAL: Could not find Tcl and/or Tk library paths. Aborting build.")
                  sys.exit(1)
              if tcl_dir == tk_dir:
                  print(f"âŒ FATAL: Tcl and Tk paths are identical ({tcl_dir}), which indicates a detection error. Aborting.")
                  sys.exit(1)
              print(f"âœ… Found Tcl library at: {tcl_dir}")
              print(f"âœ… Found Tk library at: {tk_dir}")
              
              # The core Nuitka command
              cmd = [
                  '/usr/local/bin/python3.13', '-m', 'nuitka',
                  '--onefile', '--standalone', '--enable-plugin=tk-inter',
                  # OPTIMIZATION: Use --low-memory to avoid OOM (Out Of Memory) errors during compilation.
                  # This trades longer compilation time for lower memory consumption.
                  '--low-memory',
                  f'--tcl-library-dir={tcl_dir}', f'--tk-library-dir={tk_dir}',
                  f'--include-data-dir={tcl_dir}={os.path.basename(tcl_dir)}',
                  f'--include-data-dir={tk_dir}={os.path.basename(tk_dir)}',
                  '--include-data-file=app/myfont.otf=myfont.otf',
                  '--output-dir=dist', '--assume-yes-for-downloads', 'app/DownloadLog.py'
              ]
              
              print("\nðŸš€ Running Nuitka command:\n" + ' '.join(cmd) + "\n")
              # Use check=True to automatically raise an exception if the command fails
              try:
                  result = subprocess.run(cmd, capture_output=True, text=True, check=True)
                  print("âœ… Nuitka build successful!")
                  print("\n--- STDOUT ---\n", result.stdout)
                  print("\n--- Files in dist directory ---")
                  os.system('ls -lha dist/')
              except subprocess.CalledProcessError as e:
                  print("âŒ FATAL: Nuitka build failed!")
                  print("\n--- STDOUT ---\n", e.stdout)
                  print("\n--- STDERR ---\n", e.stderr)
                  sys.exit(e.returncode)
          
          if __name__ == '__main__':
              main()
          BUILD_SCRIPT

      - name: Create Optimized Multi-Stage Dockerfile
        id: create_dockerfile
        run: |
          cat > Dockerfile.build << 'EOF'
          # Stage 1: Build Python 3.13.2 from source
          FROM ubuntu:20.04 AS python-builder
          LABEL stage=python-builder
          ENV DEBIAN_FRONTEND=noninteractive
          RUN apt-get update && apt-get install -y --no-install-recommends \
              build-essential wget curl libssl-dev zlib1g-dev libncurses5-dev \
              libreadline-dev libsqlite3-dev libffi-dev tk-dev tcl-dev ca-certificates \
              && rm -rf /var/lib/apt/lists/*
          WORKDIR /tmp
          RUN wget https://www.python.org/ftp/python/3.13.2/Python-3.13.2.tgz \
              && tar -xzf Python-3.13.2.tgz
          WORKDIR /tmp/Python-3.13.2
          RUN CFLAGS="-Wno-stringop-truncation" ./configure --prefix=/usr/local --enable-optimizations \
              && make -j$(nproc) \
              && make altinstall

          # Stage 2: Build the application using Nuitka
          FROM ubuntu:20.04 AS app-builder
          LABEL stage=app-builder
          ENV DEBIAN_FRONTEND=noninteractive
          # OPTIMIZATION: Removed python3-tk (runtime package) and kept only -dev packages.
          # The runtime Tk/Tcl are not needed inside the builder container.
          RUN apt-get update && apt-get install -y --no-install-recommends \
              build-essential tk-dev tcl-dev blt libsqlite3-0 libssl1.1 patchelf \
              && rm -rf /var/lib/apt/lists/*
          
          COPY --from=python-builder /usr/local /usr/local
          
          WORKDIR /app
          COPY requirements.txt ./
          COPY app ./app/
          COPY build_app.py ./build_app.py
          
          # Pip install will use the cache from the GitHub Actions cache step
          RUN /usr/local/bin/python3.13 -m pip install --no-cache-dir --upgrade pip \
              && /usr/local/bin/python3.13 -m pip install --no-cache-dir -r requirements.txt \
              && /usr/local/bin/python3.13 -m pip install --no-cache-dir nuitka
              
          RUN /usr/local/bin/python3.13 build_app.py

          # Stage 3: Create the final, minimal runtime image
          FROM ubuntu:20.04
          LABEL stage=final-runtime
          ENV DEBIAN_FRONTEND=noninteractive
          # These are the runtime libraries required for the final binary to run.
          RUN apt-get update && apt-get install -y --no-install-recommends \
              tcl8.6 tk8.6 libsqlite3-0 libssl1.1 \
              && rm -rf /var/lib/apt/lists/*
          
          WORKDIR /app
          COPY --from=app-builder /app/dist/DownloadLog.bin .
          RUN chmod +x DownloadLog.bin
          
          CMD ["./DownloadLog.bin"]
          EOF

      # --- Build Docker Image for ARM64 ---
      # CRITICAL FIX: Added --memory=4g to allocate more RAM to the build container.
      # This directly addresses the "operation was canceled" error caused by the C compiler running out of memory.
      - name: Build Docker Image for ARM64
        run: |
          docker buildx build \
            --platform linux/arm64 \
            --load \
            --memory=4g \
            -f Dockerfile.build \
            -t py-app-builder:latest \
            .

      # --- Extract Binary from Docker Image ---
      # OPTIMIZATION: Added `set -e` to ensure the script exits if any command fails.
      - name: Extract Binary from Docker Image
        run: |
          set -e
          mkdir -p final_binary
          docker run --rm \
            -v "$(pwd)/final_binary":/output \
            py-app-builder:latest \
            cp /app/DownloadLog.bin /output/

      # --- Verify Final Binary ---
      - name: Verify Final Binary
        run: |
          echo "--- Verifying final artifact ---"
          if [ -f final_binary/DownloadLog.bin ]; then
            echo "âœ… Binary successfully extracted!"
            file final_binary/DownloadLog.bin
            ls -lh final_binary/DownloadLog.bin
          else
            echo "âŒ FATAL: Binary not found after build!"
            exit 1
          fi

      # --- Upload Artifact ---
      # OPTIMIZATION: Artifact name is more descriptive.
      - name: Upload Artifact
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: DownloadLog-ubuntu-arm64-py313
          path: final_binary/DownloadLog.bin
